{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"gedixr","text":"<p>Extract the variables you need from GEDI L2A/L2B HDF5 files  and start working with them as a <code>geopandas.GeoDataFrame</code> or <code>xarray.Dataset</code> in  no time!</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Download GEDI data directly from NASA's Earthdata servers using Harmony API</li> <li>Command-line interface for quick extraction from a directory of HDF5 files</li> <li>Logging to monitor extraction progress and issues</li> <li>Quality filtering built-in with the option to skip and apply custom filters later</li> <li>Spatial subsetting using common vector file formats (GeoJSON, GeoPackage, etc.)</li> <li>GeoParquet output for efficient storage and processing</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"CLIPython <pre><code># Extract default L2B variables\ngedixr extract /path/to/gedi/data --product L2B\n\n# Extract default L2A variables with spatial subset\ngedixr extract /path/to/gedi/data -p L2A -v my_area.geojson\n</code></pre> <pre><code>from gedixr.extract import extract_data\n\n# Extract default L2B variables\ngdf_l2b, out_path_l2b = extract_data(directory=\"path/to/data\", gedi_product='L2B')\n\n# Extract default L2A variables with spatial subset\ngdf_l2a, out_path_l2a = extract_data(\n    directory=\"path/to/data\",\n    gedi_product='L2A',\n    subset_vector=\"my_area.geojson\"\n)\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation Guide - Set up gedixr on your system</li> <li>Quick Start - Get up and running in minutes</li> <li>CLI Reference - Command-line interface documentation</li> <li>Python API - Python API reference</li> </ul>"},{"location":"#about-gedi","title":"About GEDI","text":"<p>The Global Ecosystem Dynamics Investigation (GEDI) is a NASA mission that provides  high-resolution laser ranging observations of the 3D structure of the Earth's forests  and topography. Learn more at gedi.umd.edu.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the License page for  details.</p>"},{"location":"api/","title":"Python API","text":"<p>The Python API provides programmatic access to gedixr's functionality for custom  workflows.</p>"},{"location":"api/#core-functions","title":"Core Functions","text":""},{"location":"api/#download_data","title":"download_data","text":"<p>Download GEDI data using NASA Harmony API based on a time range and spatial subset. Please note that if <code>subset_vector</code> is provided, the download will be subset to the bounding box of the vector geometry and not the exact geometry itself. To perform precise spatial subsetting, use the vector file again during data extraction.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str or Path</code> <p>Directory where downloaded files will be saved. A subdirectory named after the GEDI product will be created within this directory and files will be saved there.</p> required <code>gedi_product</code> <code>str</code> <p>GEDI product name: 'L2A' or 'L2B'</p> required <code>time_range</code> <code>tuple of str</code> <p>Time range as (start_date, end_date) in format 'YYYY-MM-DD'</p> <code>None</code> <code>subset_vector</code> <code>str or Path</code> <p>Path to vector file for spatial subsetting. Please note that the download will  be subset to the bounding box of the vector geometry and not the exact geometry  itself. To perform precise spatial subsetting, use the vector file again during  data extraction. If provided, takes precedence over subset_bbox.</p> <code>None</code> <code>subset_bbox</code> <code>tuple of float</code> <p>Bounding box as (min_lon, min_lat, max_lon, max_lat).</p> <code>None</code> <code>job_id</code> <code>str</code> <p>Harmony job ID to resume a previous download. If provided, a new request will not be submitted and other parameters (time_range, subset_*) are ignored.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print progress messages</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple of (list of Path, str)</code> <p>Downloaded file paths and the job ID for potential resumption.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Initial download\n&gt;&gt;&gt; files, job_id = download_data(\n...     directory='data/gedi',\n...     gedi_product='L2A',\n...     time_range=('2020-01-01', '2020-01-31'),\n...     subset_bbox=(-10, 40, 5, 50)\n... )\n&gt;&gt;&gt; # Resume interrupted download\n&gt;&gt;&gt; files, job_id = download_data(\n...     directory='data/gedi',\n...     gedi_product='L2A',\n...     job_id=job_id\n... )\n</code></pre> Source code in <code>gedixr/download.py</code> <pre><code>def download_data(directory: str | Path,\n                  gedi_product: str,\n                  time_range: Optional[tuple[str, str]] = None,\n                  subset_vector: Optional[str | Path] = None,\n                  subset_bbox: Optional[tuple[float, float, float, float]] = None,\n                  job_id: Optional[str] = None,\n                  verbose: bool = True\n                  ) -&gt; list[Path]:\n    \"\"\"\n    Download GEDI data using NASA Harmony API based on a time range and spatial subset.\n    Please note that if `subset_vector` is provided, the download will be subset to the\n    bounding box of the vector geometry and not the exact geometry itself. To perform\n    precise spatial subsetting, use the vector file again during data extraction.\n\n    Parameters\n    ----------\n    directory : str or Path\n        Directory where downloaded files will be saved. A subdirectory named after the\n        GEDI product will be created within this directory and files will be saved there.\n    gedi_product : str\n        GEDI product name: 'L2A' or 'L2B'\n    time_range : tuple of str, optional\n        Time range as (start_date, end_date) in format 'YYYY-MM-DD'\n    subset_vector : str or Path, optional\n        Path to vector file for spatial subsetting. Please note that the download will \n        be subset to the bounding box of the vector geometry and not the exact geometry \n        itself. To perform precise spatial subsetting, use the vector file again during \n        data extraction. If provided, takes precedence over subset_bbox.\n    subset_bbox : tuple of float, optional\n        Bounding box as (min_lon, min_lat, max_lon, max_lat).\n    job_id : str, optional\n        Harmony job ID to resume a previous download. If provided, a new request\n        will not be submitted and other parameters (time_range, subset_*) are ignored.\n    verbose : bool, default=True\n        Whether to print progress messages\n\n    Returns\n    -------\n    tuple of (list of Path, str)\n        Downloaded file paths and the job ID for potential resumption.\n\n    Examples\n    --------\n    &gt;&gt;&gt; # Initial download\n    &gt;&gt;&gt; files, job_id = download_data(\n    ...     directory='data/gedi',\n    ...     gedi_product='L2A',\n    ...     time_range=('2020-01-01', '2020-01-31'),\n    ...     subset_bbox=(-10, 40, 5, 50)\n    ... )\n    &gt;&gt;&gt; # Resume interrupted download\n    &gt;&gt;&gt; files, job_id = download_data(\n    ...     directory='data/gedi',\n    ...     gedi_product='L2A',\n    ...     job_id=job_id\n    ... )\n    \"\"\"\n    short_name = con.PRODUCT_MAPPING.get(gedi_product.upper())\n    if short_name is None:\n        raise ValueError(f\"Parameter 'gedi_product': expected to be one of \"\n                        f\"{list(con.PRODUCT_MAPPING.keys())}; got '{gedi_product}' instead\")\n\n    directory = Path(directory)\n    if not directory.exists():\n        raise ValueError(f\"Directory does not exist: {directory}\")\n    download_dir = directory.joinpath(gedi_product.upper())\n    download_dir.mkdir(parents=True, exist_ok=True)\n\n    harmony_client = _authenticate_earthdata()\n\n    job_id_file = download_dir.joinpath('.harmony_job_id')\n    if job_id is None:\n        if job_id_file.exists():\n            saved_job_id = job_id_file.read_text().strip()\n            if verbose:\n                print(f\"Found existing job ID from previous run: {saved_job_id}\")\n                print(\"To resume this job, pass job_id parameter.\")\n                print(\"Submitting new request...\")\n\n        if time_range is not None:\n            time_range = {'start': dt.datetime.fromisoformat(time_range[0]),\n                          'stop': dt.datetime.fromisoformat(time_range[1])}\n\n        bbox = _get_bbox(subset_vector, subset_bbox)\n\n        capabilities = harmony_client.submit(CapabilitiesRequest(short_name=short_name))\n        collection = Collection(id=capabilities['conceptId'])\n        request = Request(\n            collection=collection,\n            spatial=bbox,\n            temporal=time_range\n        )\n        if not request.is_valid():\n            raise ValueError(f\"Invalid Harmony request: {request.validate()}\")\n\n        job_id = harmony_client.submit(request)        \n        job_id_file.write_text(job_id)\n        if verbose:\n            print(f\"Job submitted with ID: {job_id}\")\n            print(f\"Job ID saved to: {job_id_file}\")\n    else:\n        if verbose:\n            print(f\"Resuming job with ID: {job_id}\")\n\n        job_id_file.write_text(job_id)\n\n    if verbose:\n        print(\"Files will be processed by Harmony before proceeding with download...\")\n\n    try:\n        result_json = harmony_client.result_json(job_id, show_progress=verbose)\n        status = result_json.get('status', 'unknown')\n        if status == 'failed':\n            _failed_status(download_dir, job_id, job_id_file, result_json)\n        elif status not in ['successful', 'complete']:\n            warnings.warn(\n                f\"Harmony job status is '{status}'. Proceeding with download but results may be incomplete.\",\n                UserWarning\n            )\n        if verbose:\n            print(\"Processing complete. Starting download...\")\n\n        results = harmony_client.download_all(\n            job_id,\n            directory=str(download_dir),\n            overwrite=True\n        )    \n\n        file_paths = [Path(f.result()) for f in results]\n        if verbose:\n            print(f\"Downloaded {len(file_paths)} file(s) to {download_dir}\")\n        if len(file_paths) == 0:\n            warnings.warn(\n                \"No files were downloaded. This may indicate an issue with the request or data availability.\",\n                UserWarning\n            )\n\n        if job_id_file.exists():\n            job_id_file.unlink()\n\n        return file_paths, job_id\n\n    except (KeyboardInterrupt, Exception) as e:\n        if verbose:\n            if isinstance(e, KeyboardInterrupt):\n                print(f\"\\nDownload interrupted by user. Job ID saved to: {job_id_file}\")\n            else:\n                print(f\"\\nDownload interrupted due to error: {e}\")\n                print(f\"Job ID saved to: {job_id_file}\")\n            print(\"To resume, run:\")\n            print(f\"  download_data(directory='{directory}', gedi_product='{gedi_product}', job_id='{job_id}')\")\n            print(\"or use the CLI with --job-id option.\")\n        raise\n</code></pre>"},{"location":"api/#extract_data","title":"extract_data","text":"<p>Extracts data from GEDI L2A or L2B files in HDF5 format using the following steps:</p> <p>(1) Search a root directory recursively for GEDI L2A or L2B HDF5 files (2) OPTIONAL: Filter files by month of acquisition (3) Extract data from each file for specified beams and variables into a Dataframe (4) OPTIONAL: Filter out shots of poor quality (5) Convert Dataframe to GeoDataFrame including geometry column (6) OPTIONAL: Subset shots spatially using intersection via provided vector     file or list of vector files (7) Save the result as a GeoParquet file or multiple files (one per     provided vector file, if applicable) (8) Return a GeoDataFrame or dictionary of GeoDataFrame objects (one per provided     vector file, if applicable)</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>Root directory to recursively search for GEDI L2A/L2B files.</p> required <code>gedi_product</code> <code>str</code> <p>GEDI product type. Either 'L2A' or 'L2B'. Default is 'L2B'.</p> required <code>variables</code> <code>Optional[list[tuple[str, str]]]</code> <p>List of tuples containing the desired column name in the returned GeoDataFrame and the GEDI layer name to be extracted. Defaults to those retrieved by <code>gedixr.constants.DEFAULT_VARIABLES['&lt;gedi_product&gt;']</code>.</p> <code>None</code> <code>beams</code> <code>Optional[str | list[str]]</code> <p>Which GEDI beams to extract values from? Defaults to all beams (power and coverage beams). Use <code>'power'</code> or <code>'coverage'</code> for power or coverage beams, respectively. You can also provide a list of beam names, e.g.: <code>['BEAM0101', 'BEAM0110']</code>.</p> <code>None</code> <code>filter_month</code> <code>Optional[tuple[int, int]]</code> <p>Filter GEDI shots by month of the year? E.g. (6, 8) to only keep shots that were acquired between June 1st and August 31st of each year. Defaults to (1, 12), which keeps all shots of each year.</p> <code>None</code> <code>subset_vector</code> <code>Optional[str | Path | list[str | Path]]</code> <p>Path or list of paths to vector files in a fiona supported format to subset the GEDI data spatially. Default is None, to keep all shots. Note that the basename of each vector file will be used in the output names, so it is recommended to give those files reasonable names beforehand!</p> <code>None</code> <code>apply_quality_filter</code> <code>bool</code> <p>Apply a basic quality filter to the GEDI data? Default is True. This basic filtering strategy will filter out shots with quality_flag != 1, degrade_flag != 0, num_detectedmodes &gt; 1, and difference between detected elevation and DEM elevation &lt; 100 m.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>GeoDataFrame or dictionary</code> <p>In case of an output dictionary, these are the expected key, value pairs:     <code>{'&lt;Vector Basename&gt;': {'geo': Polygon, 'gdf': GeoDataFrame, 'path': Path}}</code>     where 'geo' is the geometry of the vector file, 'gdf' is the extracted     GeoDataFrame for that geometry, and 'path' is the path to the output     GeoParquet file. If no vector files were provided, a single GeoDataFrame is returned.</p> <code>out_path</code> <code>Path or None</code> <p>In case no vector files were provided, the path to the output GeoParquet file is returned. Otherwise, None is returned as the output paths are included in the output dictionary.</p> Source code in <code>gedixr/extract.py</code> <pre><code>def extract_data(directory: str | Path,\n                 gedi_product: str,\n                 variables: Optional[list[tuple[str, str]]] = None,\n                 beams: Optional[str| list[str]] = None,\n                 filter_month: Optional[tuple[int, int]] = None,\n                 subset_vector: Optional[str | Path | list[str | Path]] = None,\n                 apply_quality_filter: bool = True\n                 ) -&gt; (GeoDataFrame | dict[str, dict[str, GeoDataFrame | Polygon] | Path], Optional[Path]):\n    \"\"\"\n    Extracts data from GEDI L2A or L2B files in HDF5 format using the following\n    steps:\n\n    (1) Search a root directory recursively for GEDI L2A or L2B HDF5 files\n    (2) OPTIONAL: Filter files by month of acquisition\n    (3) Extract data from each file for specified beams and variables into a Dataframe\n    (4) OPTIONAL: Filter out shots of poor quality\n    (5) Convert Dataframe to GeoDataFrame including geometry column\n    (6) OPTIONAL: Subset shots spatially using intersection via provided vector\n        file or list of vector files\n    (7) Save the result as a GeoParquet file or multiple files (one per\n        provided vector file, if applicable)\n    (8) Return a GeoDataFrame or dictionary of GeoDataFrame objects (one per provided\n        vector file, if applicable)\n\n    Parameters\n    ----------\n    directory: str or Path\n        Root directory to recursively search for GEDI L2A/L2B files.\n    gedi_product: str\n        GEDI product type. Either 'L2A' or 'L2B'. Default is 'L2B'.\n    variables: list of tuple of str, optional\n        List of tuples containing the desired column name in the returned\n        GeoDataFrame and the GEDI layer name to be extracted. Defaults to those\n        retrieved by `gedixr.constants.DEFAULT_VARIABLES['&lt;gedi_product&gt;']`.\n    beams: str or list of str, optional\n        Which GEDI beams to extract values from? Defaults to all beams (power and\n        coverage beams). Use `'power'` or `'coverage'` for power or coverage beams,\n        respectively. You can also provide a list of beam names, e.g.:\n        `['BEAM0101', 'BEAM0110']`.\n    filter_month: tuple(int), optional\n        Filter GEDI shots by month of the year? E.g. (6, 8) to only keep shots\n        that were acquired between June 1st and August 31st of each year.\n        Defaults to (1, 12), which keeps all shots of each year.\n    subset_vector: str or Path or list of str or Path, optional\n        Path or list of paths to vector files in a fiona supported format to\n        subset the GEDI data spatially. Default is None, to keep all shots.\n        Note that the basename of each vector file will be used in the output\n        names, so it is recommended to give those files reasonable names\n        beforehand!\n    apply_quality_filter: bool, optional\n        Apply a basic quality filter to the GEDI data? Default is True. This basic\n        filtering strategy will filter out shots with quality_flag != 1,\n        degrade_flag != 0, num_detectedmodes &gt; 1, and difference between detected\n        elevation and DEM elevation &lt; 100 m.\n\n    Returns\n    -------\n    GeoDataFrame or dictionary\n        In case of an output dictionary, these are the expected key, value pairs:\n            `{'&lt;Vector Basename&gt;': {'geo': Polygon, 'gdf': GeoDataFrame, 'path': Path}}`\n            where 'geo' is the geometry of the vector file, 'gdf' is the extracted\n            GeoDataFrame for that geometry, and 'path' is the path to the output\n            GeoParquet file.\n        If no vector files were provided, a single GeoDataFrame is returned.\n    out_path: Path or None\n        In case no vector files were provided, the path to the output GeoParquet\n        file is returned. Otherwise, None is returned as the output paths are\n        included in the output dictionary.\n    \"\"\"\n    if gedi_product not in con.ALLOWED_PRODUCTS:\n        raise RuntimeError(f\"Parameter 'gedi_product': expected to be one of \"\n                           f\"{con.ALLOWED_PRODUCTS}; got {gedi_product} instead\")\n\n    directory = anc.to_pathlib(x=directory)\n    subset_vector = anc.to_pathlib(x=subset_vector) if \\\n        (subset_vector is not None) else None\n    log_handler, now = anc.set_logging(directory, gedi_product)\n    anc.log(handler=log_handler, mode='info',\n            msg=f\"Starting GEDI {gedi_product} data extraction using parameters: \"\n                f\"variables={variables}, beams={beams}, \"\n                f\"filter_month={filter_month}, \"\n                f\"subset_vector={subset_vector}, \"\n                f\"apply_quality_filter={apply_quality_filter}\")\n\n    anc.error_tracker.reset() \n    out_dict = None\n    if gedi_product == 'L2A':\n        variables = con.DEFAULT_VARIABLES['L2A'] if variables is None else variables\n        pattern = con.PATTERN_L2A\n    else:\n        variables = con.DEFAULT_VARIABLES['L2B'] if variables is None else variables\n        pattern = con.PATTERN_L2B\n    if beams is None:\n        beams = con.POWER_BEAMS + con.COVERAGE_BEAMS\n    elif beams == 'power':\n        beams = con.POWER_BEAMS\n    elif beams == 'coverage':\n        beams = con.COVERAGE_BEAMS\n    else:\n        beams = beams\n    if filter_month is None:\n        filter_month = (1, 12)\n    if subset_vector is not None:\n        out_dict = anc.prepare_vec(vec=subset_vector)\n    layers = con.DEFAULT_BASE[gedi_product] + variables\n\n    try:\n        # (1) Search for GEDI files\n        filepaths = [p for p in directory.rglob('*') if p.is_file() and\n                     p.match(pattern)]\n\n        if len(filepaths) == 0:\n            raise RuntimeError(f\"No GEDI {gedi_product} files were found in \"\n                               f\"{directory}.\")\n\n        gdf_list_no_spatial_subset = []\n        for i, fp in enumerate(tqdm(filepaths)):\n            # (2) Filter by month of acquisition\n            date = _date_from_gedi_file(gedi_path=fp)\n            if filter_month[0] &gt; filter_month[1]:\n                filter_month = (filter_month[1], filter_month[0])\n            if not filter_month[0] &lt;= date.month &lt;= filter_month[1]:\n                msg = (f\"Time of acquisition outside of filter range: \"\n                       f\"month_min={filter_month[0]}, \"\n                       f\"month_max={filter_month[1]}\")\n                anc.log(handler=log_handler, mode='info', file=fp.name, msg=msg)\n                continue\n\n            try:\n                gedi = h5py.File(fp, 'r')\n\n                # (3) Extract data for specified beams and variables\n                df = pd.DataFrame(_from_file(gedi=gedi,\n                                             gedi_fp=fp,\n                                             gedi_product=gedi_product,\n                                             beams=beams,\n                                             layers=layers,\n                                             acq_time=date,\n                                             log_handler=log_handler))\n\n                # (4) Filter by quality flags\n                if apply_quality_filter:\n                    df = _filter_quality(df=df, log_handler=log_handler, gedi_path=fp)\n\n                # (5) Convert to GeoDataFrame, set 'Shot Number' as index and convert\n                # acquisition time to datetime\n                df['geometry'] = df.apply(lambda row:\n                                          Point(row.longitude, row.latitude),\n                                          axis=1)\n                df = df.drop(columns=['latitude', 'longitude'])\n                gdf = gp.GeoDataFrame(df)\n                gdf.set_crs(epsg=4326, inplace=True)\n                gdf['acq_time'] = pd.to_datetime(gdf['acq_time'])\n\n                # (6) Subset spatially if any vector files were provided\n                if subset_vector is not None:\n                    for k, v in out_dict.items():\n                        gdf_sub = gdf[gdf.intersects(v['geo'])]\n                        if not gdf_sub.empty:\n                            if out_dict[k]['gdf'] is None:\n                                out_dict[k]['gdf'] = gdf_sub\n                            else:\n                                gdf_cat = pd.concat([out_dict[k]['gdf'], gdf_sub])\n                                out_dict[k]['gdf'] = gdf_cat\n                        del gdf_sub\n                else:\n                    if not gdf.empty:\n                        gdf_list_no_spatial_subset.append(gdf)\n\n                gedi.close()\n                del df, gdf\n            except Exception as msg:\n                anc.log(handler=log_handler, mode='exception', file=fp.name,\n                        msg=str(msg))\n                anc.error_tracker.increment()\n\n        # (7) &amp; (8)\n        flt = 1 if apply_quality_filter else 0\n        out_dir = directory / 'extracted'\n        out_dir.mkdir(exist_ok=True)\n        if subset_vector is not None:\n            for k, v in out_dict.items():\n                v['path'] = None\n                if v['gdf'] is not None:\n                    out_path = out_dir.joinpath(f'{now}_{gedi_product}_{flt}_{k}.parquet')\n                    v['gdf'].to_parquet(out_path)\n                    v['path'] = out_path\n            return out_dict, None\n        else:\n            out_path = None\n            # make sure that gdf's in list are not all empty \n            if gdf_list_no_spatial_subset:\n                out = pd.concat(gdf_list_no_spatial_subset)\n                out_path = out_dir.joinpath(f'{now}_{gedi_product}_{flt}.parquet')\n                out.to_parquet(out_path)\n            else:\n                anc.log(handler=log_handler, mode='info',\n                        msg=\"No GEDI shots passed the filtering criteria; \"\n                            \"no output file created.\")\n                out = GeoDataFrame()\n            return out, out_path\n    except Exception as msg:\n        anc.log(handler=log_handler, mode='exception', msg=str(msg))\n        anc.error_tracker.increment()\n    finally:\n        anc.close_logging(log_handler=log_handler)\n        error_count = anc.error_tracker.count\n        if error_count &gt; 0:\n            print(f\"WARNING: {error_count} errors occurred during the extraction \"\n                  f\"process. Please check the log file!\")\n</code></pre>"},{"location":"api/#post-extraction-functions","title":"Post-extraction Functions","text":""},{"location":"api/#load_to_gdf","title":"load_to_gdf","text":"<p>Loads GEDI L2A and/or L2B GeoParquet or GeoPackage files as GeoDataFrames.  If both are provided, they will be merged into a single GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>l2a</code> <code>Optional[str | Path]</code> <p>Path to a GEDI L2A GeoParquet or GeoPackage file.</p> <code>None</code> <code>l2b</code> <code>Optional[str | Path]</code> <p>Path to a GEDI L2B GeoParquet or GeoPackage file.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>final_gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing the data from the provided GEDI L2A and/or L2B files.</p> Source code in <code>gedixr/xr.py</code> <pre><code>def load_to_gdf(l2a: Optional[str | Path] = None,\n                l2b: Optional[str | Path] = None\n                ) -&gt; GeoDataFrame:\n    \"\"\"\n    Loads GEDI L2A and/or L2B GeoParquet or GeoPackage files as GeoDataFrames. \n    If both are provided, they will be merged into a single GeoDataFrame.\n\n    Parameters\n    ----------\n    l2a: str or Path, optional\n        Path to a GEDI L2A GeoParquet or GeoPackage file.\n    l2b: str or Path, optional\n        Path to a GEDI L2B GeoParquet or GeoPackage file.\n\n    Returns\n    -------\n    final_gdf: GeoDataFrame\n        GeoDataFrame containing the data from the provided GEDI L2A and/or L2B files.\n    \"\"\"\n    if all(x is None for x in [l2a, l2b]):\n        raise RuntimeError(\"At least one of the parameters 'l2a' or \"\n                           \"'l2b' must be provided!\")\n    elif all(x is not None for x in [l2a, l2b]):\n        gdf_l2a = _reader(l2a)\n        gdf_l2b = _reader(l2b)\n        final_gdf = merge_gdf(l2a=gdf_l2a, l2b=gdf_l2b)\n    else:\n        fp = l2a if l2a is not None else l2b\n        final_gdf = _reader(fp)\n        final_gdf['acq_time'] = pd.to_datetime(final_gdf['acq_time'])\n    return final_gdf\n</code></pre>"},{"location":"api/#merge_gdf","title":"merge_gdf","text":"<p>Merges the data of two GeoDataFrames containing GEDI L2A and L2B data. If dictionaries are provided, the function assumes key, value pairs of the dictionary output of <code>gedixr.extract.extract_data</code>. The function will merge the data of matching geometries and return a dictionary of GeoDataFrames.</p> <p>Parameters:</p> Name Type Description Default <code>l2a</code> <code>GeoDataFrame | dict</code> <p>GeoDataFrame or a dictionary of GeoDataFrames containing GEDI L2A data.</p> required <code>l2b</code> <code>GeoDataFrame | dict</code> <p>GeoDataFrame or a dictionary of GeoDataFrames containing GEDI L2B data.</p> required <code>how</code> <code>str</code> <p>The type of merge to be performed. Default is 'inner'.</p> <code>'inner'</code> <code>on</code> <code>Optional[str | list[str]]</code> <p>The column(s) to merge on. Default is ['geometry', 'shot', 'acq_time'].</p> <code>None</code> <p>Returns:</p> Name Type Description <code>merged_out</code> <code>GeoDataFrame or dict</code> <p>A GeoDataFrame or a dictionary of GeoDataFrames containing the merged GEDI L2A and L2B data.</p> Source code in <code>gedixr/xr.py</code> <pre><code>def merge_gdf(l2a: GeoDataFrame | dict,\n              l2b: GeoDataFrame | dict,\n              how: str = 'inner',\n              on: Optional[str | list[str]] = None\n              ) -&gt; GeoDataFrame | dict:\n    \"\"\"\n    Merges the data of two GeoDataFrames containing GEDI L2A and L2B data. If\n    dictionaries are provided, the function assumes key, value pairs of the dictionary\n    output of `gedixr.extract.extract_data`. The function will merge the data of\n    matching geometries and return a dictionary of GeoDataFrames.\n\n    Parameters\n    ----------\n    l2a: GeoDataFrame or dict\n        GeoDataFrame or a dictionary of GeoDataFrames containing GEDI L2A data.\n    l2b: GeoDataFrame or dict\n        GeoDataFrame or a dictionary of GeoDataFrames containing GEDI L2B data.\n    how: str, optional\n        The type of merge to be performed. Default is 'inner'.\n    on: str or list of str, optional\n        The column(s) to merge on. Default is ['geometry', 'shot', 'acq_time'].\n\n    Returns\n    -------\n    merged_out: GeoDataFrame or dict\n        A GeoDataFrame or a dictionary of GeoDataFrames containing the merged\n        GEDI L2A and L2B data.\n    \"\"\"\n    suffixes = ('_l2a', '_l2b')\n    if on is None:\n        on = ['geometry', 'shot', 'acq_time']\n    if all([isinstance(gdf, dict) for gdf in [l2a, l2b]]):\n        if len(l2a.keys()) != len(l2b.keys()):\n            print(f\"WARNING: The provided dictionaries contain data from a \"\n                  f\"different number of geometries: \"\n                  f\"({len(l2a.keys())} vs. {len(l2b.keys())}).\"\n                  f\"\\nOnly data of matching geometries will be merged and returned.\")\n\n        matched = set(l2a.keys()).intersection(set(l2b.keys()))\n        if len(matched) == 0:\n            raise RuntimeError(\"No matching geometries found between the provided \"\n                               \"dictionaries.\")\n\n        merged_out = {}\n        for aoi in matched:\n            _run_checks(l2a[aoi], l2b[aoi], key=aoi)\n            merged_gdf = l2b[aoi]['gdf'].merge(l2a[aoi]['gdf'],\n                                               how=how, on=on, suffixes=suffixes)\n            merged_out[aoi] = {}\n            merged_out[aoi]['gdf'] = merged_gdf\n            merged_out[aoi]['geo'] = l2a[aoi]['geo']\n    elif all([isinstance(gdf, GeoDataFrame) for gdf in [l2a, l2b]]):\n        _compare_gdfs(l2a, l2b)\n        merged_out = l2b.merge(l2a, how=how, on=on, suffixes=suffixes)\n    else:\n        raise RuntimeError(\"The provided input is not supported.\")\n    return merged_out\n</code></pre>"},{"location":"api/#gdf_to_xr","title":"gdf_to_xr","text":"<p>Rasterizes a GeoDataFrame containing GEDI L2A/L2B data to an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing GEDI L2A/L2B data.</p> required <code>measurements</code> <code>Optional[list[str]]</code> <p>List of measurements names (i.e. GEDI variables) to be included. Default is None, which will include all measurements.</p> <code>None</code> <code>resolution</code> <code>Optional[tuple[float, float]]</code> <p>A tuple of the pixel spacing of the returned data (Y, X). This includes the direction (as indicated by a positive or negative number). Default is (-0.0003, 0.0003), which corresponds to a spacing of 30 m.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>cube</code> <code>Dataset</code> <p>An xarray Dataset containing the rasterized GEDI data.</p> Source code in <code>gedixr/xr.py</code> <pre><code>def gdf_to_xr(gdf: GeoDataFrame,\n              measurements: Optional[list[str]] = None,\n              resolution: Optional[tuple[float, float]] = None\n              ) -&gt; Dataset:\n    \"\"\"\n    Rasterizes a GeoDataFrame containing GEDI L2A/L2B data to an xarray Dataset.\n\n    Parameters\n    ----------\n    gdf: GeoDataFrame\n        GeoDataFrame containing GEDI L2A/L2B data.\n    measurements: list of str, optional\n        List of measurements names (i.e. GEDI variables) to be included.\n        Default is None, which will include all measurements.\n    resolution: tuple of float, optional\n        A tuple of the pixel spacing of the returned data (Y, X). This includes\n        the direction (as indicated by a positive or negative number). Default\n        is (-0.0003, 0.0003), which corresponds to a spacing of 30 m.\n\n    Returns\n    -------\n    cube: Dataset\n        An xarray Dataset containing the rasterized GEDI data.\n    \"\"\"\n    if resolution is None:\n        resolution = (-0.0003, 0.0003)\n    xr_ds = make_geocube(vector_data=gdf,\n                         measurements=measurements,\n                         output_crs=f'epsg:{gdf.crs.to_epsg()}',\n                         resolution=resolution)\n    return xr_ds\n</code></pre>"},{"location":"download/","title":"Downloading GEDI Data","text":"<p>The <code>gedixr</code> package provides functionality to download GEDI data directly using NASA's  Harmony API. This feature allows you to download GEDI L2A or L2B data for your area and  time period of interest without manually navigating NASA Earthdata Search.</p>"},{"location":"download/#prerequisites-and-authentication","title":"Prerequisites and Authentication","text":"<p>Before downloading GEDI data, you need to create a NASA Earthdata account at  https://urs.earthdata.nasa.gov/. You might also need  to configure your credentials for programmatic access. We use the <code>earthaccess</code> library  for handling authentication, which will first look for a <code>.netrc</code> file or environment  variables for your credentials. If you haven't set either up, the library will prompt  you for your username and password the first time you run a download.  </p> <p>See their authentication documentation  for details.</p>"},{"location":"download/#usage","title":"Usage","text":""},{"location":"download/#basic-example","title":"Basic Example","text":"CLIPython <pre><code>gedixr download data/gedi \\\n    --product L2A \\\n    --time-start 2019-01-01 \\\n    --time-end 2020-12-31 \\\n    --subset-vector study_area.geojson\n</code></pre> <pre><code>files, job_id = download_data(\n    directory='data/gedi',\n    gedi_product='L2A',\n    time_range=('2019-01-01', '2020-12-31'),\n    subset_vector='study_area.geojson'\n)\n</code></pre> <p>Bounding Box Subsetting</p> <p>When using <code>--subset-vector</code>, the download will be subset to the bounding box of  the vector geometry, not the exact geometry bounds. This is a current simplification  in the download process.</p> <p>For precise spatial subsetting to your exact area of interest, use the vector file  again during the extraction step.</p>"},{"location":"download/#hybrid-example-earthdata-search-web-interface-gedixr","title":"Hybrid Example: Earthdata Search web interface + gedixr","text":"<p>You can also first use the Earthdata Search web interface to interactively select the  GEDI data you want with more options to subset the data than currently provided by <code>gedixr</code>. After submitting your request on the Earthdata Search website, you should be  able to see your request under 'Download Status &amp; History'. After clicking on your request and navigating to \"Order Status\", you should find an  \"Order ID\", which is equivalent to the Harmony job ID. You can then use this job ID to  download the requested data using <code>gedixr</code>:</p> CLIPython <pre><code>gedixr download data/gedi \\\n    --product L2B \\\n    --job-id your_order_id_here\n</code></pre> <pre><code>files, job_id = download_data(\n    directory='data/gedi',\n    gedi_product='L2B',\n    job_id='your_order_id_here'\n)\n</code></pre>"},{"location":"download/#options","title":"Options","text":""},{"location":"download/#required-parameters","title":"Required Parameters","text":"<ul> <li><code>directory</code>: Directory where files will be saved. A subdirectory named after the  product (L2A or L2B) will be created automatically.</li> <li><code>--product</code> / <code>-p</code>: GEDI product type ('L2A' or 'L2B')</li> </ul>"},{"location":"download/#spatial-subsetting-one-required-unless-resuming-with-job-id","title":"Spatial Subsetting (one required unless resuming with <code>--job-id</code>)","text":"<ul> <li><code>--subset-vector</code> / <code>-v</code>: Path to vector file for spatial subsetting</li> <li><code>--bbox</code>: Bounding box as 'min_lon,min_lat,max_lon,max_lat'</li> </ul>"},{"location":"download/#temporal-filtering-optional","title":"Temporal Filtering (optional)","text":"<ul> <li><code>--time-start</code> / <code>-s</code>: Start date in YYYY-MM-DD format</li> <li><code>--time-end</code> / <code>-e</code>: End date in YYYY-MM-DD format</li> </ul> <p>Note</p> <p>Both <code>--time-start</code> and <code>--time-end</code> must be provided together.</p>"},{"location":"download/#resume-options","title":"Resume Options","text":"<ul> <li><code>--job-id</code>: Harmony job ID to resume a previous download</li> </ul>"},{"location":"download/#other-options","title":"Other Options","text":"<ul> <li><code>--quiet</code> / <code>-q</code>: Suppress progress messages (CLI only)</li> </ul>"},{"location":"download/#output","title":"Output","text":"<p>Downloaded files are saved in a subdirectory named after the GEDI product within your  specified directory. E.g., if you download L2B data to <code>data/gedi/</code>, the files will be  saved to:</p> <pre><code>data/gedi/\n\u2514\u2500\u2500 L2B/\n    \u251c\u2500\u2500 GEDI02_B_2020001000000_O12345_01_T12345_02_005_01_V002.h5\n    \u251c\u2500\u2500 GEDI02_B_2020002000000_O12346_01_T12346_02_005_01_V002.h5\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"download/#python-api-return-values","title":"Python API Return Values","text":"<p>The <code>download_data</code> function returns a tuple of:</p> <ol> <li><code>file_paths</code>: A list of <code>Path</code> objects pointing to the downloaded files</li> <li><code>job_id</code>: The Harmony job ID (useful for resuming if needed)</li> </ol> <pre><code>files, job_id = download_data(...)\n\nprint(f\"Downloaded {len(files)} files\")\nprint(f\"First file: {files[0]}\")\nprint(f\"Job ID: {job_id}\")\n</code></pre>"},{"location":"download/#how-it-works","title":"How It Works","text":"<p>The download process consists of two stages:</p> <ol> <li>Processing: Harmony processes your request on NASA's servers, subsetting the  data according to your spatial and temporal filters</li> <li>Downloading: Once processing is complete, the files are downloaded to your local  machine</li> </ol> <p>You'll see progress messages for both stages:</p> <pre><code>Job submitted with ID: abc123def456\nJob ID saved to: data/gedi/L2B/.harmony_job_id\nFiles will be processed by Harmony before proceeding with download...\nProcessing: 0%\nProcessing: 9%\nProcessing: 54%\nProcessing: 100%\nProcessing complete. Starting download...\nDownloaded 15 file(s) to data/gedi/L2B\n</code></pre>"},{"location":"download/#troubleshooting","title":"Troubleshooting","text":""},{"location":"download/#authentication-errors","title":"Authentication Errors","text":"<p>We use the <code>earthaccess</code> library for handling NASA Earthdata authentication. See their  authentication documentation  for setup details. If you encounter authentication errors, verify:</p> <ol> <li>Your <code>.netrc</code> file exists and has correct permissions</li> <li>Your credentials are correct</li> <li>You've accepted all required Earthdata agreements (check NASA Earthdata website)</li> </ol>"},{"location":"download/#resuming-interrupted-downloads","title":"Resuming Interrupted Downloads","text":"<p>Downloads can take considerable time depending on the data volume. If a download is  interrupted (e.g., network issues, system shutdown), you should be able to resume it  using the job ID:</p> CLIPython <pre><code># The job ID will be shown when you start the download\n# and saved to a .harmony_job_id file in the download directory\ngedixr download data/gedi \\\n    --product L2B \\\n    --job-id abc123def456\n</code></pre> <pre><code># Resume using the job_id returned from the initial download\nfiles, job_id = download_data(\n    directory='data/gedi',\n    gedi_product='L2B',\n    job_id='abc123def456'\n)\n</code></pre> <p>Job ID Storage</p> <p>When you start a download, the job ID is automatically saved to a <code>.harmony_job_id</code>  file in the download directory (e.g., <code>data/gedi/L2B/.harmony_job_id</code>). This file is  deleted upon successful completion but persists if the download is interrupted.</p>"},{"location":"download/#processing-errors","title":"Processing Errors","text":"<p>If the Harmony job fails during processing, <code>gedixr</code> will:</p> <ul> <li>Save detailed error information to a JSON file (e.g., <code>{job_id}_error.json</code>)</li> <li>Display a summary of the errors encountered</li> <li>Show which error messages occurred most frequently</li> </ul> <p>Example error output:</p> <pre><code>RuntimeError: Harmony job failed: 75 percent maximum errors exceeded\nError details saved to: data/gedi/L2B/abc123def456_error.json\n\nTotal errors: 185\nError summary:\n  - 185x: Invalid temporal range, both start and end required.\n</code></pre>"},{"location":"download/#large-downloads","title":"Large Downloads","text":"<p>For large spatial or temporal extents, downloads can take significant time. Consider:</p> <ul> <li>Breaking your request into smaller chunks (e.g., by month or sub-regions)</li> <li>Using the <code>--quiet</code> flag to reduce output</li> <li>Running downloads in a <code>screen</code> or <code>tmux</code> session for long-running processes</li> <li>Using the Earthdata Search web interface instead, which may handle large requests more  robustly.</li> </ul>"},{"location":"download/#connection-issues","title":"Connection Issues","text":"<p>If download is interrupted due to connection issues, simply resume using the <code>--job-id</code>  option with the job ID that was displayed or saved in the <code>.harmony_job_id</code> file.</p> <p>Two-Stage Subsetting</p> <p>Notice how the vector file is used in both steps:</p> <ol> <li>Download: Reduces the amount of data downloaded by subsetting to the vector's  bounding box</li> <li>Extraction: Performs precise spatial filtering to the exact vector geometry</li> </ol> <p>This two-stage approach minimizes download time while ensuring accurate spatial  subsetting.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#latest-version-from-github","title":"Latest Version from GitHub","text":""},{"location":"installation/#1-create-and-activate-an-environment","title":"1. Create and activate an environment","text":"<p>Create a conda environment with the required dependencies:</p> <pre><code>conda env create --file https://raw.githubusercontent.com/maawoo/gedixr/main/environment.yml\nconda activate gedixr_env\n</code></pre> <p>Tip</p> <p>We recommend using Mamba as a faster alternative to Conda.</p>"},{"location":"installation/#2-install-gedixr","title":"2. Install gedixr","text":"<p>Install the package into the activated environment:</p> <pre><code>pip install git+https://github.com/maawoo/gedixr.git\n</code></pre>"},{"location":"installation/#specific-version","title":"Specific Version","text":"<p>See the Tags section of the repository for available versions:</p> <pre><code>conda env create --file https://raw.githubusercontent.com/maawoo/gedixr/v0.6.0/environment.yml\nconda activate gedixr_env\npip install git+https://github.com/maawoo/gedixr.git@v0.6.0\n</code></pre>"},{"location":"license/","title":"License","text":"<p>gedixr is licensed under the MIT License.</p>"},{"location":"license/#mit-license","title":"MIT License","text":"<pre><code>MIT License\n\nCopyright (c) 2023-2026 Marco Wolsza\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"license/#what-this-means","title":"What This Means","text":"<p>The MIT License is a permissive license that allows you to:</p> <ul> <li>\u2705 Use the software for any purpose (commercial or non-commercial)</li> <li>\u2705 Modify the source code</li> <li>\u2705 Distribute the software</li> <li>\u2705 Sublicense the software</li> <li>\u2705 Use it privately</li> </ul> <p>Requirements:</p> <ul> <li>Include the original copyright notice and license in any copies or substantial portions of the software</li> </ul> <p>Limitations:</p> <ul> <li>The software is provided \"as is\" without warranty</li> <li>The authors are not liable for any damages or issues arising from use of the software</li> </ul>"},{"location":"license/#contributing","title":"Contributing","text":"<p>By contributing to gedixr, you agree that your contributions will be licensed under the same MIT License.</p> <p>See the GitHub repository for contribution guidelines.</p>"},{"location":"quality/","title":"Quality Filtering","text":"<p>The extraction process automatically applies quality filtering to remove low-quality  GEDI shots. This ensures that your analysis uses reliable data. From my experience,  however, the default filters may not be appropriate for all landcover types. Therefore,  you also have the option to disable quality filtering and implement your own criteria.</p>"},{"location":"quality/#default-filtering","title":"Default Filtering","text":"<p>By default, shots are filtered based on the following conditions:</p> Filter Condition Description Quality Flag <code>quality_flag == 1</code> Shot meets quality standards Degrade Flag <code>degrade_flag == 0</code> Shot is not in a degraded state Detected Modes <code>num_detectedmodes &gt; 0</code> At least one mode was detected Elevation Check <code>abs(elev - elev_dem_tdx) &lt; 100</code> Elevation difference &lt; 100 m from DEM <p>Beam Sensitivity</p> <p>The <code>quality_flag</code> already includes filtering for beam sensitivity in the default  range of 0.9 - 1.0, so no additional sensitivity filtering is needed if this is what you want.</p>"},{"location":"quality/#filter-statistics-in-logs","title":"Filter Statistics in Logs","text":"<p>During extraction, <code>gedixr</code> logs the number and percentage of shots that were filtered  out if quality filtering is enabled. Example log entry:</p> <pre><code>INFO | GEDI02_B_2024130044637_O30619_04_T06857_02_004_01_V002.h5 | \n  00234/01567 (14.93%) shots were filtered due to poor quality\n</code></pre>"},{"location":"quality/#output-file-naming","title":"Output File Naming","text":"<p>The output filename indicates whether default quality filtering was applied by using a  suffix after the product type:</p> <ul> <li><code>YYYYMMDDHHMMSS_L2B_1.parquet</code> - Quality filtering was enabled</li> <li><code>YYYYMMDDHHMMSS_L2B_0.parquet</code> - Quality filtering was disabled</li> </ul>"},{"location":"quality/#disabling-quality-filtering","title":"Disabling Quality Filtering","text":"<p>You have the option to disable the default quality filtering during data extraction. In this case, all shots are included in the output. The <code>quality_flag</code> and <code>degrade_flag</code>  columns are still included in the output in addition to other related columns  (e.g., <code>sensitivity</code>), allowing you to apply custom filtering afterward.</p> CLIPython <pre><code>gedixr extract /path/to/data --no-quality-filter\n</code></pre> <pre><code>from gedixr.extract import extract_data\n\ngdf, out_path = extract_data(\n    directory=\"/path/to/data\",\n    gedi_product='L2B',\n    apply_quality_filter=False\n)\n</code></pre>"},{"location":"quality/#custom-quality-filtering","title":"Custom Quality Filtering","text":"<p>After extracting data without quality filtering, you can apply your own criteria:</p> <pre><code>from gedixr.extract import extract_data\n\n# Extract without default filtering\ngdf, out_path = extract_data(\n    directory=\"/path/to/data\",\n    gedi_product='L2B',\n    apply_quality_filter=False\n)\n\n# Apply custom filters\ngdf_flt = gdf[\n    (gdf['quality_flag'] == 1) &amp;\n    (gdf['degrade_flag'] == 0) &amp;\n    (gdf['num_detectedmodes'] &gt; 0) &amp;\n    (gdf['sensitivity'] &gt; 0.95) &amp; # Higher lower bound on beam sensitivity\n    (abs(gdf['elev'] - gdf['elev_dem_tdx']) &lt; 50)  # Stricter elevation check\n]\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This guide will help you get started with gedixr in just a few minutes.</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, you'll need GEDI L2A/L2B v002 files. You can either:</p> <ol> <li>Download them through the NASA Earthdata Search web interface - see here, or</li> <li>Download them using gedixr - see Downloading Data for details</li> </ol> <p>If Earthdata Search provided you with zipped files, please unzip them before proceeding.</p> <p>Spatial Subsetting</p> <p>Both NASA Earthdata Search and gedixr's download functionality allow you to subset  GEDI data to an area of interest during download, which can significantly reduce the  amount of data you need to process. You can then use <code>gedixr</code>'s spatial subsetting  during extraction for further refinement to one or multiple detailed areas of interest.</p>"},{"location":"quickstart/#basic-workflow","title":"Basic Workflow","text":""},{"location":"quickstart/#1-extract-data","title":"1. Extract data","text":"<p>The following example will:</p> <ul> <li>Recursively search for GEDI L2B files in the specified directory</li> <li>Extract the default data variables for L2B files: rh100, tcc, fhd, pai. (See    Variables for full lists of variables extracted by default.)</li> <li>Apply the default quality filtering criteria</li> <li>Save results as a GeoParquet file in the <code>extracted/</code> subdirectory relative to the  input directory and log the extraction process in the <code>log/</code> subdirectory</li> </ul> CLIPython <pre><code>gedixr extract /path/to/gedi/data --product L2B\n</code></pre> <pre><code>from gedixr.extract import extract_data\n\ngdf, out_path = extract_data(\n    directory=\"/path/to/gedi/data\",\n    gedi_product='L2B'\n)\n</code></pre>"},{"location":"quickstart/#optional-check-extraction-logs","title":"Optional: Check extraction logs","text":"<p>The extraction process logs errors and warnings. Check the <code>log/</code> subdirectory in your  input directory for detailed information if issues occur.</p>"},{"location":"quickstart/#2-load-and-merge-extracted-data","title":"2. Load and merge extracted data","text":"<p>You can load the extracted GeoParquet files back into Python for further analysis using the <code>load_to_gdf</code> function. If you extracted both L2A and L2B data, you can merge them into a single GeoDataFrame while loading.</p> <pre><code>from gedixr.xr import load_to_gdf\n\ngdf_merged = load_to_gdf(l2a=\"extracted/20260106_L2A_1.parquet\",\n                         l2b=\"extracted/20260106_L2B_1.parquet\")\n\n# or load single product:\ngdf_l2b = load_to_gdf(l2b=\"extracted/20260106_L2B_1.parquet\")\n</code></pre> <p>You can also merge L2A and L2B data directly after extraction using the <code>merge_gdf</code>  function:</p> <pre><code>from gedixr.extract import extract_data\nfrom gedixr.xr import merge_gdf\n\n# Extract both products\ngdf_l2a, out_path_l2a = extract_data(directory=\"path/to/data\", gedi_product='L2A')\ngdf_l2b, out_path_l2b = extract_data(directory=\"path/to/data\", gedi_product='L2B')\n\n# Merge them (using inner join)\ngdf_merged = merge_gdf(l2a=gdf_l2a, l2b=gdf_l2b)\n</code></pre>"},{"location":"quickstart/#3-explore-analyze-data","title":"3. Explore / Analyze data","text":"<p>Now that you have the data loaded as a <code>geopandas.GeoDataFrame</code>, you can start exploring and analyzing it using <code>geopandas</code> and <code>pandas</code>, or other related libraries. For  example, you could use the <code>xvec</code> package to extract other environmental variables from  <code>xarray</code> Datasets based on the GEDI shot locations and acquisition times and then train  a machine learning model for predicting forest structure.</p>"},{"location":"quickstart/#overview-of-extraction-options","title":"Overview of extraction options","text":"<p>The main extraction function <code>extract_data</code> (or <code>gedixr extract</code> CLI command) provides various options to customize the extraction process. Here is a quick overview of these  options, which you can combine as needed.</p>"},{"location":"quickstart/#quality-filtering","title":"Quality Filtering","text":"<p>Control whether to apply default quality filters:</p> CLIPython <pre><code># With quality filtering (default)\ngedixr extract /path/to/data --quality-filter\n\n# Without quality filtering\ngedixr extract /path/to/data --no-quality-filter\n</code></pre> <pre><code>from gedixr.extract import extract_data\n\n# With quality filtering (default)\ngdf = extract_data(\n    directory=\"/path/to/data\",\n    apply_quality_filter=True\n)\n\n# Without quality filtering\ngdf = extract_data(\n    directory=\"/path/to/data\",\n    apply_quality_filter=False\n)\n</code></pre> <p>See Quality Filtering for detailed information on the default quality filters applied as well as an example of how to implement custom filtering after  extraction.</p> <p>Output File Naming</p> <p>The output filename indicates whether quality filtering was applied by using a  boolean suffix after the product type: <code>YYYYMMDDHHMMSS_L2B_1.parquet</code> (filtered data), <code>YYYYMMDDHHMMSS_L2B_0.parquet</code>  (unfiltered data)</p>"},{"location":"quickstart/#spatial-subsetting","title":"Spatial Subsetting","text":"<p>Extract data for specific areas using vector files:</p> CLIPython <pre><code># Single area\ngedixr extract /path/to/data -v study_area.geojson\n\n# Multiple areas (creates separate output files per area)\ngedixr extract /path/to/data -v area1.geojson -v area2.geojson\n</code></pre> <pre><code>from gedixr.extract import extract_data\n\n# Single area\ngdf = extract_data(\n    directory=\"path/to/data\",\n    subset_vector=\"study_area.geojson\"\n)\n\n# Multiple areas (returns a dictionary)\nresult_dict = extract_data(\n    directory=\"path/to/data\",\n    subset_vector=[\"area1.geojson\", \"area2.geojson\"]\n)\n\n# Access individual results\narea1_gdf = result_dict['area1']['gdf']\narea2_gdf = result_dict['area2']['gdf']\n</code></pre> <p>The output GeoParquet file(s) will be saved in the <code>extracted/</code> subdirectory with the vector file basename included in the filename (e.g.,  <code>YYYYMMDDHHMMSS_L2B_1_study_area.parquet</code> for the single area example above).</p> <p>When using multiple vector files, the output dictionary will contain separate entries for each vector file with the following structure:</p> <pre><code>{'&lt;Vector Basename&gt;': {'geo': Polygon, 'gdf': GeoDataFrame}}\n</code></pre> <p>Where <code>&lt;Vector Basename&gt;</code> is the name of the vector file without the file extension, <code>geo</code> is the geometry of the area, and <code>gdf</code> is the extracted GeoDataFrame for that area.</p>"},{"location":"quickstart/#specific-months","title":"Specific Months","text":"<p>Extract only data from certain months (e.g., June to August):</p> CLIPython <pre><code>gedixr extract /path/to/data --filter-month-min 6 --filter-month-max 8\n</code></pre> <pre><code>from gedixr.extract import extract_data\n\ngdf = extract_data(\n    directory=\"path/to/data\",\n    filter_month=(6, 8)\n)\n</code></pre>"},{"location":"quickstart/#specific-beams","title":"Specific Beams","text":"<p>Extract data from specific beam types:</p> CLIPython <pre><code># Only power beams\ngedixr extract /path/to/data -b power\n\n# Only coverage beams\ngedixr extract /path/to/data -b coverage\n\n# Specific beams\ngedixr extract /path/to/data -b BEAM0101,BEAM0110\n</code></pre> <pre><code>from gedixr.extract import extract_data\n\n# Only power beams\ngdf = extract_data(directory=\"path/to/data\", beams='power')\n\n# Only coverage beams\ngdf = extract_data(directory=\"path/to/data\", beams='coverage')\n\n# Specific beams\ngdf = extract_data(\n    directory=\"path/to/data\",\n    beams=['BEAM0101', 'BEAM0110']\n)\n</code></pre>"},{"location":"quickstart/#custom-variables","title":"Custom Variables","text":"<p>You can specify custom variables to extract instead of the default variables. See  Variables for more details.</p> CLIPython <pre><code># Extract custom variables using column_name=layer_name pairs\ngedixr extract /path/to/data --product L2A \\\n  --variables \"rh50=rh50,rh75=rh75,treecover=land_cover_data/landsat_treecover\"\n</code></pre> <pre><code>from gedixr.extract import extract_data\n\nvariables = [\n    ('rh50', 'rh50'),\n    ('rh75', 'rh75'),\n    ('treecover', 'land_cover_data/landsat_treecover')\n]\ngdf = extract_data(\n    directory=\"/path/to/data\",\n    gedi_product='L2A',\n    variables=variables\n)\n</code></pre>"},{"location":"variables/","title":"Default Variables","text":"<p>In addition to shot number, acquisition time, and geolocation information, the  following variables are extracted by default if no custom variables are provided via  the <code>variables</code> parameter (see \"Custom Variables\" section below).</p>"},{"location":"variables/#gedi-l2a","title":"GEDI L2A","text":"<p>Product: GEDI Level 2A (Geolocated Elevation and Height Metrics)</p> Variable Description GEDI Layer Name <code>rh98</code> Relative height metrics at 98% interval <code>rh98</code>"},{"location":"variables/#gedi-l2b","title":"GEDI L2B","text":"<p>Product: GEDI Level 2B (Canopy Cover and Vertical Profile Metrics)</p> Variable Description GEDI Layer Name <code>rh100</code> Height above ground of received waveform signal start <code>rh100</code> <code>tcc</code> Total canopy cover <code>cover</code> <code>fhd</code> Foliage Height Diversity <code>fhd_normal</code> <code>pai</code> Total Plant Area Index <code>pai</code>"},{"location":"variables/#additional-base-variables-always-included","title":"Additional Base Variables (Always Included)","text":"Variable Description GEDI Layer Name <code>shot</code> Shot number (unique identifier) <code>shot_number</code> <code>acq_time</code> Acquisition time Derived from filename <code>latitude</code> Latitude of lowest mode <code>lat_lowestmode</code> <code>longitude</code> Longitude of lowest mode <code>lon_lowestmode</code> <code>elev</code> Elevation of lowest mode <code>elev_lowestmode</code> <code>elev_dem_tdx</code> Digital elevation model (TanDEM-X) <code>digital_elevation_model</code> <code>sensitivity</code> Beam sensitivity <code>sensitivity</code> <code>num_detectedmodes</code> Number of detected modes <code>num_detectedmodes</code>"},{"location":"variables/#further-information","title":"Further Information","text":"<p>For comprehensive overviews of all available layers in each product:</p> <ul> <li>GEDI L2A Product Information</li> <li>GEDI L2B Product Information</li> </ul>"},{"location":"variables/#custom-variables","title":"Custom Variables","text":"<p>You can specify custom variables to extract using the <code>variables</code> parameter when calling the <code>extract_data</code> function, or via the <code>--variables</code> option in the CLI.</p> <p>The <code>variables</code> parameter accepts a list of tuples, where each tuple contains the  desired variable name and the corresponding, exact (!) GEDI layer name after the beam  prefix.</p> CLIPython <pre><code># Extract custom variables using column_name=layer_name pairs\ngedixr extract /path/to/data --product L2A \\\n  --variables \"rh50=rh50,rh75=rh75,solar_azimuth=solar_azimuth,treecover=land_cover_data/landsat_treecover\"\n</code></pre> <pre><code>from gedixr.extract import extract_data\n\nvariables = [\n    ('rh50', 'rh50'),\n    ('rh75', 'rh75'),\n    ('solar_azimuth', 'solar_azimuth'),\n    ('treecover', 'land_cover_data/landsat_treecover')\n]\ngdf, out_path = extract_data(\n    directory=\"/path/to/data\",\n    gedi_product='L2A',\n    variables=variables\n)\n</code></pre> <p>This will extract the <code>rh50</code>, <code>rh75</code>, <code>solar_azimuth</code>, and <code>landsat_treecover</code> variables in addition to the default base variables. As you can see, for nested variables (like <code>landsat_treecover</code>), you need to provide the full path within the HDF5 structure after the beam prefix (e.g., <code>BEAM0001/land_cover_data/landsat_treecover</code> as it appears in  the overview linked above). In the example, the <code>landsat_treecover</code> variable will appear in the output GeoDataFrame with the column name <code>treecover</code>.</p> <p>Limitations</p> <p>GEDI L2A and L2B products contain a looot of variables. Not all of them can be  directly extracted like this. Particularly, variables that are stored as arrays  (e.g., waveform data) are not supported for extraction via the <code>variables</code> parameter  at this time. Contributions are welcome! \ud83d\ude0a</p>"}]}